# React 勘测笔记 III - render 的“运行”

我们继续基于如下代码讨论：

```js
// [code A]
import React from 'react';
import ReactDOM from 'react-dom';

class SourceProbe extends React.Component {
  render() {
    return <div id="root">Rua!</div>
  }
}

const SourceProbeElement = React.createElement(SourceProbe)
const rootContainer = document.getElementById('app');
const renderCallback = () => {};
ReactDOM.render(SourceProbeElement, rootContainer, renderCallback);
```

## `legacyRenderSubtreeIntoContainer` 的下半场

:dolphin: [ReactDom.js @function legacyRenderSubtreeIntoContainer](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-dom/src/client/ReactDOM.js)

在创建完 `_reactRootContainer` 之后，实际上就来到了 `root.render(children, callback)`，实际上相当于：

```js
unbatchedUpdates = () => {
  container._reactRootContainer.render(
    SourceProbeElement,
    () => { renderCallback(SourceProbe) },
  )
}
```

其中 `unbatchedUpdates` 参见 :dolphin: [ReactFiberScheduler.js @function unbatchedUpdates](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js)。实际上这里的批量更新就是在处理事务的合并执行，比如 `setState` 的多次连续执行就会被 `batchedUpdates` 优化为一次执行。显然初始化 root 时没必要进行合并优化，也不应该等待其他 update 事务。

## `ReactRoot.prototype.render`

其中 `ReactWork` 可以看作一个没有 reject 相关功能的 Promise，相当于，即在 `work._onCommit` 执行后，`callback` 才会被调用。

## `ReactFiberReconciler.updateContainer`

:dolphin: [ReactFiberScheduler.js @function updateContainer](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberReconciler.js)

计算出 `currentTime` 和 `expirationTime`，执行 `updateContainerAtExpirationTime`。

## `ReactFiberScheduler.requestCurrentTime`

:dolphin: [ReactFiberScheduler.js @function requestCurrentTime](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js)

