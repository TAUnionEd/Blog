# React 勘测笔记 III - render 的“运行”

我们继续基于如下代码讨论：

```js
// [code A]
import React from 'react';
import ReactDOM from 'react-dom';

class SourceProbe extends React.Component {
  render() {
    return <div id="root">Rua!</div>
  }
}

const SourceProbeElement = React.createElement(SourceProbe)
const rootContainer = document.getElementById('app');
const renderCallback = () => {};
ReactDOM.render(SourceProbeElement, rootContainer, renderCallback);
```

## `legacyRenderSubtreeIntoContainer` 的下半场

:dolphin: [ReactDom.js @function legacyRenderSubtreeIntoContainer](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-dom/src/client/ReactDOM.js#598)

在创建完 `_reactRootContainer` 之后，实际上就来到了 `root.render(children, callback)`，实际上相当于：

```js
unbatchedUpdates = () => {
  container._reactRootContainer.render(
    SourceProbeElement,
    () => { renderCallback(SourceProbe) },
  )
}
```

`unbatchedUpdates` 参见 :dolphin: [ReactFiberScheduler.js @function unbatchedUpdates](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js)。实际上这里的批量更新就是在处理事务的合并执行，比如 `setState` 的多次连续执行就会被 `batchedUpdates` 优化为一次执行。显然初始化 root 时没必要进行合并优化，也不应该等待其他 update 事务。

## `ReactRoot.prototype.render`

:dolphin: [ReactDom.js @ReactRoot.prototype.render](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-dom/src/client/ReactDOM.js#375)

调用 `updateContainer` 对根节点进行更新，使用 `ReactWork` 保证传入的回调在更新之后进行。

`ReactWork` 可以看作一个没有 reject 相关功能的 Promise，相当于，即在 `work._onCommit` 执行后，`callback` 才会被调用。

## `ReactFiberReconciler.updateContainer`

:dolphin: [ReactFiberScheduler.updateContainer](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberReconciler.js#283)

  计算出 `currentTime` 和 `expirationTime`，传入 `updateContainerAtExpirationTime` 并执行。

- 计算 `currentTime`：

  - :dolphin: [`ReactFiberScheduler.requestCurrentTime`](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js@2043)

    初次执行时无其他作用，调用 `recomputeCurrentRendererTime`

  - :dolphin: [`ReactFiberScheduler.recomputeCurrentRendererTime`](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js#1949)

    计算出当前时间和 React 初始化时的时间差，传入 `msToExpirationTime`，并将结果赋值到 `ReactFiberScheduler.currentRendererTime`

  - :dolphin: [`ReactFiberExpirationTime.msToExpirationTime`](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberExpirationTime.js#23)

    实际上就是计算公式：

    ```js
    Math.pow(2, 30) - 1 - 1 - ((ms / 10) | 0)
    ```

    即时间差越大，过期时间越小。其中 2^30 - 1 即是最大的带符号整数，也是 v8 引擎在 32 位环境下最大的整数。

- 计算 `expirationTime`：

  - :dolphin: [`ReactFiberScheduler.computeUniqueAsyncExpiration`](https://github.com/TAUnionOtto/react-interpretation/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js@1596)

